// Code generated by streamlogger/generator. DO NOT EDIT.
// source: {{.Source}}

package {{.Package}}

import (
	"context"
	"fmt"

	"github.com/sirupsen/logrus"
	"github.com/ubuntu/zsys/internal/streamlogger"
	"google.golang.org/grpc"
)

/*
  Clients generated code
*/
{{- range .Clients}}

// {{.LogClient}} is a grpc {{.OrigClient}} (*{{.PrivateClient}}), augmented by a connexion id in context.
type {{.LogClient}} struct {
	{{.OrigClient}}
	Ctx context.Context
}

// New{{.OrigClient}}WithLogs returns a {{.LogClient}}, which can send logs at level "level", attached to the given context
func New{{.OrigClient}}WithLogs(ctx context.Context, cc *grpc.ClientConn, level logrus.Level) *{{.LogClient}} {
	return &{{.LogClient}}{
		{{.OrigClient}}: New{{.OrigClient}}(cc),
		Ctx:        streamlogger.NewClientCtx(ctx, level),
	}
}

// Close tear downs the connection under the {{.LogClient}}.
func (z *{{.LogClient}}) Close() error {
	return z.{{.OrigClient}}.(*{{.PrivateClient}}).cc.Close()
}
{{- end}}

/*
   Servers
*/
{{- range .Servers}}

// {{.LogServer}} is used to intercept the server and inserting an intermediate log stream.
// This can't be done in interceptor as the creation of each per-function server struct from a grpc.ServerStream
// is only done in the handler() call, which is blocking until the whole handler has ran, once the stream
// has closed.
type {{.LogServer}} struct {
	{{.OrigServer}}
}

// Register{{.OrigServer}}WithLogs wraps the server to a logged variant intercepting all grpc calls.
func Register{{.OrigServer}}WithLogs(s *grpc.Server, srv {{.OrigServer}}) {
	Register{{.OrigServer}}(s, &{{.LogServer}}{srv})
}
{{- end}}

{{- range .Calls}}

/*
 * {{.Service}}.{{.Name}}()
 */

// {{.LogStream}} is a {{.OrigStream}} augmented by its own Context containing the log streamer
type {{.LogStream}} struct {
	{{.OrigStream}}
	ctx context.Context
}

// Context access the log streamer context
func (s *{{.LogStream}}) Context() context.Context {
	return s.ctx
}

// {{.Name}} overrides {{.OrigServer}} {{.Name}}, installing a logger first
func (z *{{.LogServer}}) {{.Name}}(req *{{.ReqType}}, stream {{.OrigStream}}) error {
	// it's ok to panic in the assertion as we expect to have generated above the Write() function.
	ctx, err := streamlogger.AddLogger(stream.(streamlogger.StreamLogger), "{{.Name}}")
	if err != nil {
		return fmt.Errorf("couldn't attach a logger to request: %w", err)
	}

	// wrap the context to access the context with logger
	return z.{{.OrigServer}}.{{.Name}}(req, &{{.LogStream}}{
		{{.OrigStream}}: stream,
		ctx:                   ctx,
	})
}
{{- end}}

/*
 * Extend streams to io.Writer
 */
{{- range .Writers}}

// Write promote {{.Stream}} to an io.Writer
func (s *{{.Stream}}) Write(p []byte) (n int, err error) {
	err = s.Send(
		&{{.MessageType}}{
		  {{- if.OneOfField}}
			{{.OneOfField}}: &{{.LogField}}{Log: string(p)},
		  {{- else}}
			{{.LogField}}: string(p),
		  {{- end}}
		})
	if err != nil {
		return 0, err
	}

	return len(p), nil
}
{{- end}}
