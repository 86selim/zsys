// Code generated by streamlogger/generator. DO NOT EDIT.
// source: zsys.pb.go

package zsys

import (
	"context"
	"fmt"

	"github.com/sirupsen/logrus"
	"github.com/ubuntu/zsys/internal/streamlogger"
	"google.golang.org/grpc"
)

/*
  Clients generated code
*/

// ZsysLogClient is a grpc ZsysClient (*zsysClient), augmented by a connexion id in context.
type ZsysLogClient struct {
	ZsysClient
	Ctx context.Context
}

// newZsysClientWithLogs returns a ZsysLogClient, which can send logs at level "level", attached to the given context
func newZsysClientWithLogs(ctx context.Context, cc *grpc.ClientConn, level logrus.Level) *ZsysLogClient {
	return &ZsysLogClient{
		ZsysClient: NewZsysClient(cc),
		Ctx:        streamlogger.NewClientCtx(ctx, level),
	}
}

// Close tear downs the connection under the ZsysLogClient.
func (z *ZsysLogClient) Close() error {
	return z.ZsysClient.(*zsysClient).cc.Close()
}

/*
   Servers
*/

// ZsysLogServer is used to intercept the server and inserting an intermediate log stream.
// This can't be done in interceptor as the creation of each per-function server struct from a grpc.ServerStream
// is only done in the handler() call, which is blocking until the whole handler has ran, once the stream
// has closed.
type ZsysLogServer struct {
	ZsysServer
}

// registerZsysServerWithLogs wraps the server to a logged variant intercepting all grpc calls.
func registerZsysServerWithLogs(s *grpc.Server, srv ZsysServer) {
	RegisterZsysServer(s, &ZsysLogServer{srv})
}

/*
 * Zsys.CreateUserData()
 */

// zsysCreateUserDataLogStream is a Zsys_CreateUserDataServer augmented by its own Context containing the log streamer
type zsysCreateUserDataLogStream struct {
	Zsys_CreateUserDataServer
	ctx context.Context
}

// Context access the log streamer context
func (s *zsysCreateUserDataLogStream) Context() context.Context {
	return s.ctx
}

// CreateUserData overrides ZsysServer CreateUserData, installing a logger first
func (z *ZsysLogServer) CreateUserData(req *CreateUserDataRequest, stream Zsys_CreateUserDataServer) error {
	// it's ok to panic in the assertion as we expect to have generated above the Write() function.
	ctx, err := streamlogger.AddLogger(stream.(streamlogger.StreamLogger), "CreateUserData")
	if err != nil {
		return fmt.Errorf("couldn't attach a logger to request: %w", err)
	}

	// wrap the context to access the context with logger
	return z.ZsysServer.CreateUserData(req, &zsysCreateUserDataLogStream{
		Zsys_CreateUserDataServer: stream,
		ctx:                       ctx,
	})
}

/*
 * Extend streams to io.Writer
 */

// Write promote zsysCreateUserDataServer to an io.Writer
func (s *zsysCreateUserDataServer) Write(p []byte) (n int, err error) {
	err = s.Send(
		&LogResponse{
			Log: string(p),
		})
	if err != nil {
		return 0, err
	}

	return len(p), nil
}
